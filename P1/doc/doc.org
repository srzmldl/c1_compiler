* 各程序设计思路以及克服C1的简陋性
  这几个程序都思路非常简单,我就挑几个重点说:
  - calcSum求和, 主要测试了clang,gcc对待const的不同规则.验证了附录2中的内容.
  - factorial中,由于函数不能传参,但是两个函数需要共用参数,那么就只能通过全局变量实现
  - pickMax中,a[i]在a[i-1]的基础上生成,采用乘以c1,再加c2之后模质数的方法.当溢出int时,会直接占用符号位,所以这里生成了负数
  - bubleSort中,采用循环嵌套,实现冒泡排序.虽然没有for循环,但有while循环,所以本质一样,无非就是把for循环的三个部份分开写.
  - generatePermutation中,采用回溯的方法,回溯之后必须还原变量和标记数组.每次找到第一个没有被标记的作为递归到的这个位置的值,保证了依字典序输出排列.同时,不能传参,递归变量now仍然需要采用全局变量实现
    
* 第三题
  C源程序分成若干模块,存储在不同的文件中.C编译系统对这些源文件分别进行预处理,编译,汇编形成可重定位的目标文件;然后再利用连接器将这些目标文件和必要的库文件链接成一个可执行的目标文件.
** 预处理
   - 文件包含: 拓展成程序正文(如include).在相应路径寻找指定文件再展开.
   - 宏展开: 将类似define定义的宏在引用位置展开
   - 条件编译: 作用与#if和#defif这类.将源程序某部份包含进来或者排出在外.
  
** 编译
   - 最简单的汇编器两遍扫描.第一遍,扫描输入,将存储单元所有标识符存入符号表,并分配地址.第二遍翻译成机器语言中代表那个操作的位串,并翻译出标识符.
   - 如果汇编代码有外部符号引用,则还需要link一遍
   - gcc -S main.c 即可得到main.s,即汇编码
** 连接器
   - 连接是一个收集,组织程序所需的不同代码和数据的过程,以便程序能被装入内存并执行.
   - 连接可以在将源代码翻译成机器代码的编译时候完成,也可以在程序装入内存并执行的装入时完成,甚至可以在程序运行时完成
   - 两种连接器
     + 静态连接器:负责将多个可重定位目标文件组成一个可执行文件
     + 动态连接器:支持在内存中的可执行程序在执行时与共享目标文件进行动态的连接.
   - 连接器主要完成如下两个任务:
     + 符号解析:连接器识别各个目标模块中定义和引用的符号,为每个符号引用确定所关联的一个同名符号定义
     + 重定位: 编译器和汇编器产生的代码节和数据节分别都是零地址开始.连接器按如下方式来重定位这两节:将每一个符号关联到一个内存位置,然后修改所有对这些符号的引用,以使得它们指向相关联的内存位置.
** LLVM相关指令
   - LLVM 可以用于编译的各个过程
   - LLVM IR 的文件后缀是 .ll, Bytecode 文件后缀是 .bc
   - llvm 然后tab自动补全,各种命令就都出来了.下面举出重要的例子(指令有很多,不一一举出了,需要时看帮助即可,这里只完成一个编译分解流程)
     + lli hello.ll 直接运行hello.ll
     + llc hello.ll 汇编生成hello.s
     + gcc hello.s -o hello 用gcc将hello.s编译成二进制可执行文件

       